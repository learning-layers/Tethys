//
// @author Gordon Lawrenz <lawrenz@dbis.rwth-aachen.de>
//
// use gradle.properties to define parameters
// see gradle.properties.example for help
//
apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'eclipse'
apply plugin: 'cargo-base'

import org.gradle.api.file.FileCollection
import org.gradle.api.plugins.cargo.convention.Deployable
import org.gradle.api.plugins.cargo.tasks.remote.CargoDeployRemote
import org.apache.tools.ant.filters.ReplaceTokens

task wrapper(type: Wrapper) {
  gradleVersion = '2.2'
}

sourceCompatibility = 1.7

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.gradle.api.plugins:gradle-cargo-plugin:1.5.1'
    }
}

repositories {
    mavenCentral()
    flatDir { dirs "lib" }
} 

//------------
//Lists for easier dependency management
//------------
List swagger = [
//	'com.wordnik:swagger-annotations:1.3.12',							//Annotations for eclipse. Uncomment it for testing purposes without Swagger 
	'com.wordnik:swagger-jersey2-jaxrs_2.11:1.3.12',					//Provides Swagger for Jersey 2.0
]
List javax = [
	'javax.servlet:javax.servlet-api:3.0.1',							//only for eclipse as tomcat7 already uses servlet-api 3.0
	'org.eclipse.persistence:javax.persistence:2.1.0'
]
List jersey = [
	'org.glassfish.jersey.containers:jersey-container-servlet:2.13',
	'org.glassfish.jersey.containers:jersey-container-servlet-core:2.13',
	'org.glassfish.jersey.ext:jersey-proxy-client:2.13'
]
List hibernate = [
	'org.hibernate:hibernate-core:4.1.1.Final',
	'org.hibernate:hibernate-entitymanager:4.1.1.Final',
	'org.hibernate:hibernate-validator:4.2.0.Final',
]
List google = [
	'com.google.code.gson:gson:2.2.4'
]
List mysql = [
	'mysql:mysql-connector-java:5.1.34'
]

//------------
//new configuration for custom cargo tasks
//------------
configurations {
	remoteRuntime{
		transitive = false
	}
}

//------------
//Dependency for our configurations
//------------
dependencies {
	testCompile group: 'junit', name: 'junit', version: '4.+'
	
	compile javax, jersey, apache, google, mysql, swagger, hibernate
	
	//swagger is a servlet itself so it need to be deployed within the war and cannot be in the lib of the webserver
	//minimal set of jersey needs to be shipped! it's atm not on the server
	remoteRuntime swagger, jersey
}

test {
    systemProperties 'property': 'value'
}

uploadArchives {
    repositories {
       flatDir {
           dirs 'repos'
       }
    }
}

processResources {
	from('src/main/resources') {
		include '*.properties'
		filter(ReplaceTokens, tokens: ['swaggerWebApplicationName': 'Tethys'])
		filter(ReplaceTokens, tokens: ['swaggerWebApplicationHost': 'localhost'])
		filter(ReplaceTokens, tokens: ['swaggerWebApplicationPort': '8081'])
	}
}
				
//------------
//Classes For cargo tasks
//------------
//Environment class, provides all necessary information of the server for the cargo plugin
class RemoteEnvironment {
	String containerId
	String hostname
	Integer port
	String username
	String password
}

//Container class, provides all necessary of the be deployed container for the cargo plugin
class Container {
    String name
    @Nested
    RemoteEnvironment remoteEnvironment
    String context
}

//------------
//Definitions for cargo tasks
//------------
//List of remote action types
def remoteTypes = ['deploy','redeploy','undeploy']

//Map of all remote server environments
def remoteEnvironments = [
	'TethysServer': new RemoteEnvironment(
		containerId:	cargo_containerId,
		hostname:		cargo_hostname, 
		port:			cargo_port as Integer,
		username:		cargo_username,
		password:		cargo_password
	),
	'TestServer': new RemoteEnvironment(
		containerId:	cargo_containerId,
		hostname:		cargo_testhostname, 
		port:			cargo_port as Integer,
		username:		cargo_username,
		password:		cargo_password
	)
]

//List of all Containers
def containers = [
	new Container(
		name:				cargo_deployName,	
		context:			cargo_deployName,
		remoteEnvironment:	remoteEnvironments.get('TethysServer')
	),
	new Container(
		name:				cargo_developName,
		context:			cargo_developName+cargo_deployName,
		remoteEnvironment:	remoteEnvironments.get('TethysServer')
	),
	new Container(
		name:				cargo_testName,
		context:			cargo_testName+cargo_deployName,
		remoteEnvironment:	remoteEnvironments.get('TestServer')
	)
]		

//------------
//Provides all cargo tasks
//------------
remoteTypes.each { type ->
	containers.each { config ->
		//Defines Cargo tasks for specified remote action types and containers 
		task "remote${type.capitalize()}${config.name.capitalize()}" (type: Class.forName("org.gradle.api.plugins.cargo.tasks.remote.Cargo${type.capitalize()}Remote")) {
			containerId	= config.remoteEnvironment.containerId
			port		= config.remoteEnvironment.port
			deployables	= [new Deployable(file: file(war.archivePath), context: config.context)]
   	 		hostname	= config.remoteEnvironment.hostname
			username	= config.remoteEnvironment.username
			password	= config.remoteEnvironment.password
		
			//Print the used settings before executing the cargo task
			doFirst{
				println "-------------------------------------"
				println "Cargo Settings:"
				println "Target: http://${config.remoteEnvironment.hostname}:${config.remoteEnvironment.port}/${config.context}"
				println "User credentials: ${config.remoteEnvironment.username}:${config.remoteEnvironment.password}"
				println "-------------------------------------"
			}
			//Manipulate the web.xml so that swagger knows our api.path
			doFirst{
				
				processResources {
					from('src/main/resources') {
						include '*.properties'
						filter(ReplaceTokens, tokens: 
							[
								'swaggerWebApplicationName': config.context,
								'swaggerWebApplicationHost': config.remoteEnvironment.hostname,
								'swaggerWebApplicationPort': config.remoteEnvironment.port as String,
							]
						)
					}
				}
			
				//Only put swagger .jars into .war (without transitions)
				sourceSets.main.runtimeClasspath -= files([configurations.testCompile])
				sourceSets.main.runtimeClasspath -= files([configurations.compile])
				sourceSets.main.runtimeClasspath += files([configurations.remoteRuntime])
				println ":compileJava"
				compileJava.execute()
				println ":processResources"
				processResources.execute()
				println ":classes"
				classes.execute()
				println ":war"
				war.execute()
				println ":assemble"
				assemble.execute()
				println ":build"
				build.execute()
   			}
		}
	}
}
